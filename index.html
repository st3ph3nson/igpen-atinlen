<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Argot Translator</title>

  <style>
    :root{
      --bg:#0b132b;
      --panel:#f3f4f6;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border:rgba(15,23,42,0.15);
      --accent:#38bdf8;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg), #111827);
      color: var(--text);
      padding: 24px;
    }
    .wrap{ max-width: 980px; margin: 0 auto; }
    header{ color:#fff; margin-bottom: 16px; }
    header h1{ margin:0 0 6px 0; font-size: 22px; letter-spacing: .3px; font-weight: 750; }
    header p{ margin:0; color: rgba(255,255,255,0.75); font-size: 14px; line-height: 1.4; }

    .grid{ display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1fr 1fr; } }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.18);
    }
    label{ display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    textarea{
      width:100%;
      min-height: 210px;
      resize: vertical;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      outline: none;
      font-size: 14px;
      line-height: 1.45;
    }
    textarea:focus{
      border-color: rgba(56,189,248,.65);
      box-shadow: 0 0 0 3px rgba(56,189,248,.22);
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      margin-top: 10px;
    }
    .pill{
      display:flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      font-size: 13px;
    }
    .pill input{ transform: translateY(1px); }

    button{
      appearance:none;
      border: 1px solid var(--border);
      background: #fff;
      padding: 9px 12px;
      border-radius: 12px;
      font-weight: 650;
      cursor:pointer;
      font-size: 13px;
    }
    button:hover{
      border-color: rgba(56,189,248,.75);
      box-shadow: 0 0 0 3px rgba(56,189,248,.18);
    }

    .small{
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
      line-height: 1.35;
    }

    .mapbox{
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      background: #f8fafc;
      border: 1px dashed rgba(15,23,42,0.2);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color:#0f172a;
      overflow:auto;
      white-space: pre;
      max-height: 220px;
    }

    details.mapping-details{
      margin-top: 10px;
      border-top: 1px solid rgba(15,23,42,0.08);
      padding-top: 8px;
    }
    details.mapping-details > summary{
      cursor: pointer;
      list-style: none;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
    }
    details.mapping-details > summary::-webkit-details-marker{ display:none; }
    details.mapping-details > summary::before{
      content: "▸";
      font-size: 12px;
      opacity: 0.9;
      transform: translateY(-0.5px);
    }
    details.mapping-details[open] > summary::before{ content: "▾"; }
    details.mapping-details > summary:hover{
      border-color: rgba(56,189,248,.75);
      box-shadow: 0 0 0 3px rgba(56,189,248,.18);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>Argot Translator</h1>
      <p>Each English letter becomes a fixed syllable. Vowels are atomic: <b>AP EP IP OP UP</b>. Punctuation preserved.</p>
    </header>

    <div class="grid">
      <div class="card">
        <label for="input">English input</label>
        <textarea id="input" placeholder="Type here... e.g. My name is Adam and I want a car."></textarea>

        <div class="controls">
          <div class="pill">
            <input type="radio" id="modeSpaced" name="mode" value="spaced" checked>
            <label for="modeSpaced" style="margin:0;color:inherit;">Spaced (learning)</label>
          </div>

          <div class="pill">
            <input type="radio" id="modeFused" name="mode" value="fused">
            <label for="modeFused" style="margin:0;color:inherit;">Fused (fluent)</label>
          </div>

          <div class="pill" id="sepPill">
            <input type="checkbox" id="useDots">
            <label for="useDots" style="margin:0;color:inherit;">Use • between letters</label>
          </div>

          <div class="pill" id="pipePill">
            <input type="checkbox" id="usePipes">
            <label for="usePipes" style="margin:0;color:inherit;">Use | between words</label>
          </div>

          <div class="pill">
            <input type="checkbox" id="preserveCaps" checked>
            <label for="preserveCaps" style="margin:0;color:inherit;">Preserve capitalization</label>
          </div>

          <button id="copyBtn" type="button">Copy output</button>
          <button id="clearBtn" type="button">Clear</button>
        </div>

        <div class="small" id="tipText">
          Tip: Spaced mode shows chunks like <b>cak ap ral</b>. Toggle <b>•</b> for <b>cak•ap•ral</b>. With pipes: <b>cak•ap•ral | tak•op</b>.
        </div>
      </div>

      <div class="card">
        <label for="output">Translated output</label>
        <textarea id="output" readonly placeholder="Output appears here..."></textarea>

        <details class="mapping-details">
          <summary>Show mapping</summary>
          <div class="mapbox" id="mapbox"></div>
        </details>
      </div>
    </div>
  </div>

  <script>
    // ====== CANON MAPPING (INCLUDING ATOMIC VOWELS) ======
    const MAP = Object.freeze({
      // Vowels (atomic)
      a: "at",
      e: "egg",
      i: "it",
      o: "ox",
      u: "up",

      // Fricatives (-l)
      s: "so",
      f: "for",
      h: "hi",
      v: "vo",
      z: "zip",

      // Nasals (-n)
      m: "man",
      n: "no",

      // Liquids/glides (L-ending version)
      l: "log",
      r: "rip",
      w: "win",
      y: "yes",
 
      // Stops (-k)
      b: "be",
      c: "car",
      d: "do",
      g: "go",
      k: "keg",     // <-- your update (no CAK/KAK overlap)
      p: "pig",
      t: "to",

      // Extras
      j: "jog",
      q: "quo",
      x: "xi"
    });

    const inputEl = document.getElementById("input");
    const outputEl = document.getElementById("output");
    const mapBoxEl = document.getElementById("mapbox");

    const modeSpaced = document.getElementById("modeSpaced");
    const modeFused = document.getElementById("modeFused");
    const preserveCaps = document.getElementById("preserveCaps");

    const useDots = document.getElementById("useDots");
    const usePipes = document.getElementById("usePipes");

    const sepPill = document.getElementById("sepPill");
    const pipePill = document.getElementById("pipePill");
    const tipText = document.getElementById("tipText");

    const copyBtn = document.getElementById("copyBtn");
    const clearBtn = document.getElementById("clearBtn");

    function isLetter(ch){ return /^[A-Za-z]$/.test(ch); }
    function isWordJoiner(ch){ return ch === "'" || ch === "-"; }

    // map a single character to exactly ONE token (vowels are atomic via MAP)
    function mapChar(low){
      return MAP[low] ?? low;
    }

    function translateWord(word, mode, keepCaps, dotSep){
      const isAllCaps = keepCaps && word.length > 1 && word === word.toUpperCase();
      const isTitle = keepCaps && /^[A-Z][a-z]+$/.test(word);

      const parts = [];
      for (let idx = 0; idx < word.length; idx++){
        const ch = word[idx];

        // keep internal joiners as literal
        if (isWordJoiner(ch)){
          parts.push(ch);
          continue;
        }

        const low = ch.toLowerCase();
        parts.push(mapChar(low));
      }

      let out;
      if (mode === "spaced"){
        out = dotSep ? parts.join("•") : parts.join(" ");
      } else {
        out = parts.join("");
      }

      if (keepCaps){
        if (isAllCaps){
          out = out.toUpperCase();
        } else if (isTitle){
          out = out.charAt(0).toUpperCase() + out.slice(1);
        }
      }
      return out;
    }

    // Insert " | " between WORDS (letter-runs) when enabled.
    // We treat whitespace as the delimiter between words.
    function translateText(text, mode, keepCaps, dotSep, pipeSep){
      let i = 0;
      let out = "";

      let lastWasWord = false;
      let pendingWS = "";

      while (i < text.length){
        const ch = text[i];

        // word token = letters with optional internal ' or -
        if (isLetter(ch)){
          let j = i;
          while (j < text.length){
            const cj = text[j];
            if (isLetter(cj)) { j++; continue; }
            if (isWordJoiner(cj) && j + 1 < text.length && isLetter(text[j + 1])) { j++; continue; }
            break;
          }

          const word = text.slice(i, j);
          const translated = translateWord(word, mode, keepCaps, dotSep);

          if (lastWasWord){
            if (pipeSep && pendingWS.length){
              out += " | ";
            } else {
              out += pendingWS;
            }
          } else {
            out += pendingWS;
          }

          out += translated;

          pendingWS = "";
          lastWasWord = true;
          i = j;
          continue;
        }

        // whitespace
        if (/\s/.test(ch)){
          pendingWS += ch;
          i++;
          continue;
        }

        // punctuation/symbol
        out += pendingWS + ch;
        pendingWS = "";

        // sentence-ending punctuation breaks word-chain for pipes
        if (/[.!?]/.test(ch)) lastWasWord = false;

        i++;
      }

      out += pendingWS;
      return out;
    }

    function renderMapBox(){
      const lines = [];
      lines.push("Vowels (atomic):");
      lines.push("A → ap");
      lines.push("E → ep");
      lines.push("I → ip");
      lines.push("O → op");
      lines.push("U → up");
      lines.push("");
      lines.push("Consonants:");
      const consonantKeys = Object.keys(MAP).filter(k => !"aeiou".includes(k));
      consonantKeys.sort((a,b)=>a.localeCompare(b));
      for (const k of consonantKeys){
        lines.push(`${k.toUpperCase()} → ${MAP[k]}`);
      }
      mapBoxEl.textContent = lines.join("\n");
    }

    function syncUI(){
      const spaced = modeSpaced.checked;
      sepPill.style.display = spaced ? "flex" : "none";
      pipePill.style.display = spaced ? "flex" : "none";

      if (!spaced){
        useDots.checked = false;
        usePipes.checked = false;
      }
      if (spaced && !useDots.checked){
        usePipes.checked = false; // pipes only when dots are on (your format)
      }

      tipText.innerHTML = spaced
        ? `Tip: Spaced mode shows <b>cak ap ral</b>. Toggle <b>•</b> for <b>cak•ap•ral</b>. With pipes: <b>cak•ap•ral | tak•op</b>.`
        : `Tip: In fused mode you’ll get <b>cakapral</b> (no spaces).`;
    }

    function update(){
      syncUI();
      const mode = modeFused.checked ? "fused" : "spaced";
      const keepCaps = preserveCaps.checked;
      const dotSep = useDots.checked && mode === "spaced";
      const pipeSep = usePipes.checked && mode === "spaced" && dotSep;

      outputEl.value = translateText(inputEl.value, mode, keepCaps, dotSep, pipeSep);
    }

    inputEl.addEventListener("input", update);
    modeSpaced.addEventListener("change", update);
    modeFused.addEventListener("change", update);
    preserveCaps.addEventListener("change", update);
    useDots.addEventListener("change", update);
    usePipes.addEventListener("change", update);

    copyBtn.addEventListener("click", async () => {
      try{
        await navigator.clipboard.writeText(outputEl.value);
        copyBtn.textContent = "Copied!";
        setTimeout(()=>copyBtn.textContent="Copy output", 900);
      } catch(e){
        alert("Copy failed (clipboard permission). You can manually select + copy.");
      }
    });

    clearBtn.addEventListener("click", () => {
      inputEl.value = "";
      outputEl.value = "";
      inputEl.focus();
      update();
    });

    renderMapBox();
    update();
  </script>
</body>
</html>