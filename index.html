<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fliplish Translator</title>

  <style>
    :root {
      --bg: #d8cbb8;
      --panel: rgba(255,255,255,0.78);
      --border: rgba(17, 24, 39, 0.18);
      --text: #111827;
    }

    * { box-sizing: border-box; }
    html, body { overflow-x: hidden; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      margin: 24px;
      line-height: 1.35;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    .row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select, input[type="checkbox"] { font-size: 15px; }

    button, select {
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.65);
      cursor: pointer;
    }

    label.chk {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.45);
      user-select: none;
    }

    .hint { opacity: 0.75; font-size: 13px; margin-top: 8px; }
  </style>
</head>

<body>
<div class="container">
  <h1>Fliplish Translator</h1>

  <textarea id="input" placeholder="Type English (or coded text) here..."></textarea>

  <div class="row">
    <button id="encode">Encode →</button>
    <button id="decode">← Decode</button>
    <button id="clear">Clear</button>

    <label>
      Suffix mode:
      <select id="suffixMode">
        <option value="single" selected>Single</option>
        <option value="aeiou">AEIOU Rotate</option>
        <option value="random">Random (A–Z)</option>
      </select>
    </label>

    <label>
      Suffix:
      <select id="suffix"></select>
    </label>

    <label>
      Move letters:
      <select id="moveN">
        <option value="1" selected>1</option>
        <option value="2">2</option>
      </select>
    </label>

    <label>
      Preserve capitalization:
      <select id="caps">
        <option value="yes">Yes</option>
        <option value="no" selected>No</option>
      </select>
    </label>

    <label class="chk" title="Recommended: tries both 1-letter and 2-letter moves per word and picks the most English-looking result">
      <input id="smartDecode" type="checkbox" checked />
      Smart Decode
    </label>
  </div>

  <textarea id="output" readonly></textarea>

  <div class="hint">
    How Fliplish works: Each word is encoded by moving the first 1–2 letters to the end and adding a suffix letter.
    Decode removes that suffix letter and moves letters back, preserving punctuation and spacing.
  </div>
</div>

<script>
/* ===== Suffixes (A–Z only) ===== */
const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");

/* ===== Elements ===== */
const inputEl = document.getElementById("input");
const outputEl = document.getElementById("output");
const suffixEl = document.getElementById("suffix");
const suffixModeEl = document.getElementById("suffixMode");
const moveNEl = document.getElementById("moveN");
const capsEl = document.getElementById("caps");
const smartDecodeEl = document.getElementById("smartDecode");

/* ===== Init suffix dropdown ===== */
(function initSuffix() {
  suffixEl.innerHTML = "";
  for (const s of LETTERS) {
    const o = document.createElement("option");
    o.value = s;
    o.textContent = s.toUpperCase();
    if (s === "a") o.selected = true;
    suffixEl.appendChild(o);
  }
})();

function syncSuffixUI() {
  const disabled = suffixModeEl.value !== "single";
  suffixEl.disabled = disabled;
  suffixEl.style.opacity = disabled ? "0.55" : "1";
}
suffixModeEl.addEventListener("change", syncSuffixUI);
syncSuffixUI();

/* ===== Tokenizer ===== */
function tokenize(text) {
  return text.match(/[A-Za-z]+(?:['’][A-Za-z]+)*|[^A-Za-z]+/g) || [];
}

/* ===== Caps detection ===== */
function detectCapsStyle(word) {
  if (word === word.toUpperCase()) return "upper";
  if (
    word[0] === word[0].toUpperCase() &&
    word.slice(1) === word.slice(1).toLowerCase()
  ) return "title";
  return "lower";
}

/* ===== Encode / Decode ===== */
function encodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();

  // ✅ NEW RULE: I and IS now get the suffix too (no special "leave alone")
  // Keep them easy to speak: no moving letters, just add suffix.
  if (lower === "i" || lower === "is") {
    const coded = lower + suffix;
    if (!preserveCaps) return coded;
    if (style === "upper") return coded.toUpperCase();
    if (style === "title") return coded[0].toUpperCase() + coded.slice(1);
    return coded;
  }

  const n = Math.min(moveN, lower.length);
  let coded = lower.slice(n) + lower.slice(0, n) + suffix;

  if (!preserveCaps) return coded;
  if (style === "upper") return coded.toUpperCase();
  if (style === "title") return coded[0].toUpperCase() + coded.slice(1);
  return coded;
}

function decodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  if (!suffix || !lower.endsWith(suffix)) return word;

  const core = lower.slice(0, -suffix.length);

  // ✅ NEW RULE: ien -> i, isen -> is (works regardless of moveN)
  if (core === "i" || core === "is") {
    let plain = core;
    if (!preserveCaps) return plain;
    if (style === "upper") return plain.toUpperCase();
    if (style === "title") return plain[0].toUpperCase() + plain.slice(1);
    return plain;
  }

  const n = Math.min(moveN, core.length);
  let plain = core.slice(-n) + core.slice(0, -n);

  if (!preserveCaps) return plain;
  if (style === "upper") return plain.toUpperCase();
  if (style === "title") return plain[0].toUpperCase() + plain.slice(1);
  return plain;
}

/* ===== Encode suffix selection ===== */
function getSuffixForEncode(i) {
  const mode = suffixModeEl.value;
  if (mode === "aeiou") return ["a","e","i","o","u"][i % 5];
  if (mode === "random") return LETTERS[Math.floor(Math.random() * LETTERS.length)];
  return suffixEl.value;
}

/* ===== Decode suffix extraction (read actual last letter) ===== */
function suffixFromToken(tok) {
  const low = tok.toLowerCase();
  const last = low[low.length - 1] || "";
  return /[a-z]/.test(last) ? last : null;
}

/* ===== Transform ===== */
function transform(text, mode) {
  const preserveCaps = capsEl.value === "yes";
  let wordIndex = 0;

  return tokenize(text).map(tok => {
    if (/^[A-Za-z]/.test(tok)) {
      const moveN = +moveNEl.value;

      if (mode === "encode") {
        const suffix = getSuffixForEncode(wordIndex++);
        return encodeWord(tok, suffix, preserveCaps, moveN);
      }

      // decode: ALWAYS read suffix from the word (works for single/rotate/random)
      const sfx = suffixFromToken(tok);
      wordIndex++;
      return decodeWord(tok, sfx, preserveCaps, moveN);
    }
    return tok;
  }).join("");
}

/* ===== Buttons ===== */
document.getElementById("encode").onclick = () =>
  outputEl.value = transform(inputEl.value, "encode");

document.getElementById("decode").onclick = () =>
  outputEl.value = transform(inputEl.value, "decode");

document.getElementById("clear").onclick = () => {
  inputEl.value = "";
  outputEl.value = "";
  inputEl.focus();
};
</script>
</body>
</html>